## SSR(Server Side Rendering)

**S**erver **S**ide **R**endering의 약자로 **서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식**입니다.

![ssr_csr_1](/images/ssr_csr_1.png)

&nbsp;

### SSR의 단계별 설명

1. 유저가 웹사이트에 요청을 보냅니다.
2. 서버는 문자열로 표현된, 즉시 렌더링 가능한 HTML 파일을 만듭니다.
3. 클라이언트에 전달되는 순간, HTML은 즉시 렌더링 됩니다.
4. 클라이언트가 자바스크립트를 다운 받습니다. 자바스크립트를 다운 받는 중 로딩된 컨텐츠를 볼 수는 있지만, 조작할 수는 없는 단계입니다.
5. 다운로드가 완료되면, 브라우저가 자바스크립트 프레임워크를 실행합니다.
6. 자바스크립트까지 실행이 완료되었기 때문에, 이제 웹사이트는 상호작용이 가능한 상태가 됩니다.

&nbsp;

## CSR(Client Side Rendering)

**C**lient **S**ide **R**endering의 약자로 SSR과 달리 **클라이언트 쪽에서 렌더링을 하는 방식**입니다. 서버는 요청을 받게 되면 클라이언트에 HTML과 JS 파일을 보내고, 클라이언트는 그것을 받아 렌더링을 시작합니다.

![ssr_csr_2](/images/ssr_csr_2.png)

&nbsp;

### CSR의 단계별 설명

1. 유저가 웹사이트에 요청을 보냅니다.
2. `CDN`이 HTML 파일과 JS 파일로 접근할 수 있는 링크를 클라이언트로 보냅니다. 클라이언트가 HTML과 JS 파일을 전부 다운받기 전까지, 유저는 웹사이트를 볼 수도, 조작할 수도 없습니다.
3. 다운로드가 완료되면 브라우저가 HTML과 JS 파일을 실행합니다.
4. 자바스크립트까지 실행이 완료되었기 때문에, 이제 웹사이트는 상호작용이 가능한 상태가 됩니다.

> `CDN`은 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식입니다.

&nbsp;

## SSR VS CSR

웹페이지 로딩의 종류는 크게 두 가지로 나눌 수 있습니다. 웹사이트의 `첫 페이지를 로딩하는 것`과, `나머지를 로딩하는 것`입니다. SSR과 CSR은 서버(백엔드)와 클라이언트(프론트엔드), 어디서 파일을 렌더링 할지에 대해 다른 접근 방식을 갖고있듯, 웹사이트 로딩에 필요한 **모든 파일을 다운받을지, 필요한 부분만 다운받을지에 대해서도 다른 접근 방식**을 갖고있다.

&nbsp;

### 첫 페이지 로딩시간

SSR의 경우 필요한 부분의 HTML과 스크립트만 불러오는 반면, CSR의 경우 한번에 HTML과 스크립트를 전부 불러옵니다. 따라서 첫 페이지 로딩 속도는 SSR이 더 빠릅니다.

&nbsp;

### 나머지 페이지 로딩시간

첫 페이지 로딩 후 사이트의 다른 곳으로 이동할 때, CSR의 경우 이미 필요한 파일을 다운받았기 때문에 SSR에 비해 더 빠릅니다. SSR의 경우 첫 페이지 로딩 시에 거쳤던 과정을 정확하게 다시 거치기 때문에, 상대적으로 더 느립니다.

&nbsp;

### 검색엔진최적화(SEO) 대응

SEO는 **S**earch **E**ngine **O**ptimization의 약자로 검색 엔진이 이해하기 쉽게 웹사이트를 개발해 검색 결과 상위권에 노출될 수 있도록 하는 작업을 뜻합니다. 검색 엔진은 자동화 로봇인 '크롤러'를 통해 웹사이트를 자동으로 읽습니다. 

CSR은 자바스크립트가 실행되야 크롤러가 읽을 수 있는 `metadata`를 반환하기 때문에, 첫 페이지 로딩 시에 빈 `<body></body>` 태그만 크롤러에 반환됩니다. 하지만 CSR은 웹사이트에서 필요한 모든 파일을 첫 페이지 로딩 시 다운받기 때문에, 사이트의 다른 곳으로 이동 시에는 올바른 `metadata`가 크롤러에 반환됩니다. 

반면에 SSR의 경우 서버에서 이미 문자열로 표현된 HTML 파일을 전달하기 때문에, 첫 페이지 로딩부터 크롤러에 대부분의 `metadata`가 반환됩니다.

**리액트는 CSR에 최적화되어있는 라이브러리**이지만, Gatsby와 같은 라이브러리를 통해 리액트로 만들어진 웹앱을 미리 정적인 웹페이지로 생성하여 서버에 배포할 수 있습니다. 이렇게 만들어진 페이지는 정적이지만, 웹사이트 로딩 시 기존과 동일하게 추가적으로 JS 파일을 다운받았을 때 상호작용이 가능한 웹사이트가 됩니다.

&nbsp;

### 서버 자원 사용

SSR의 경우 첫 페이지 로딩 시에 거쳤던 과정을 사이트의 다른 곳으로 이동할 때 정확하게 다시 거치기 때문에, CSR보다 서버 자원을 더 많이 사용합니다. 반면에 CSR같은 경우 클라이언트(프론트엔드)에서 렌더링 작업을 진행하기 때문에, 상대적으로 서버의 부하가 적습니다.

&nbsp;

## 사용 권장 예시 비교

| `SSR`                          | `CSR`                        | 
|:-------------------------------|:-----------------------------| 
| 네트워크가 느릴 때                  | 네트워크가 빠를 때               | 
| SEO가 필요할 때                   | SEO가 필요 하지 않을 때          | 
| 최초 로딩이 빨라야하는 사이트를 개발할 때 | 사용자에게 보여지는 데이터가 많을 때 | 
| 메인 스크립트가 크고 로딩이 느릴 때     | 메인 스크립트가 가벼울 때          | 
| 웹사이트의 상호작용이 적을 때          | 웹사이트의 상호작용이 많을 때       | 

&nbsp;

## Reference

- [[React] SSR과 CSR의 차이](https://proglish.tistory.com/216)
- [[React] SEO, SSR, CSR의 개념과 의미](https://velog.io/@zihs0822/SEO-SSR-CSR%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9D%98%EB%AF%B8)

&nbsp;

<script src="https://utteranc.es/client.js"
        repo="xxdevbosa/blog"
        issue-term="pathname"
        label="blog"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>